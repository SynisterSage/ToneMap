/**
 * Spotify Sync Service
 * Fetches recently played tracks and enriches with audio features
 */

import * as SpotifyService from '../SpotifyService';
import { ListeningEvent, TrackInfo, AudioFeatures } from '../../types/listening';
import ListeningEventStore from '../database/ListeningEventStore';
import ContextDetector from '../context/ContextDetector';

interface SpotifyTrack {
  track: {
    id: string;
    name: string;
    artists: Array<{ name: string }>;
    album: {
      name: string;
      images: Array<{ url: string }>;
    };
    duration_ms: number;
    external_urls: {
      spotify: string;
    };
  };
  played_at: string;
}

interface SpotifyAudioFeatures {
  energy: number;
  valence: number;
  tempo: number;
  danceability: number;
  acousticness: number;
  instrumentalness: number;
  liveness: number;
  speechiness: number;
  loudness: number;
  mode: number;
  key: number;
  time_signature: number;
}

export class SpotifySync {
  private isSyncing: boolean = false;
  private lastSyncTime: Date | null = null;

  /**
   * Sync recently played tracks from Spotify
   */
  async syncRecentlyPlayed(
    userId: string,
    weatherEnabled: boolean = true,
    locationEnabled: boolean = false
  ): Promise<number> {
    if (this.isSyncing) {
      console.log('‚è≠Ô∏è  Sync already in progress, skipping...');
      return 0;
    }

    try {
      this.isSyncing = true;
      console.log('üîÑ Starting Spotify sync...');

      // Fetch recently played from Spotify
      const recentTracks = await SpotifyService.getRecentlyPlayed(50);
      
      if (!recentTracks || recentTracks.items.length === 0) {
        console.log('üì≠ No recent tracks found');
        return 0;
      }

      console.log(`üì• Found ${recentTracks.items.length} recent tracks`);

      // Filter out tracks we've already saved
      const newTracks: SpotifyTrack[] = [];
      for (const item of recentTracks.items) {
        const playedAt = new Date(item.played_at);
        const alreadyExists = await ListeningEventStore.hasEvent(
          userId,
          item.track.id,
          playedAt
        );

        if (!alreadyExists) {
          newTracks.push(item);
        }
      }

      if (newTracks.length === 0) {
        console.log('‚úÖ All tracks already synced');
        this.lastSyncTime = new Date();
        return 0;
      }

      console.log(`üìù Processing ${newTracks.length} new tracks...`);

      // Get audio features for all tracks in batch
      const trackIds = newTracks.map(item => item.track.id);
      const audioFeaturesMap = await this.fetchAudioFeaturesBatch(trackIds);

      // Create listening events
      const events: ListeningEvent[] = [];

      for (const item of newTracks) {
        const audioFeatures = audioFeaturesMap.get(item.track.id);
        if (!audioFeatures) {
          console.warn(`‚ö†Ô∏è  No audio features for track ${item.track.id}`);
          continue;
        }

        // Detect context for this track's play time
        const playedAt = new Date(item.played_at);
        const context = await ContextDetector.detectContext(weatherEnabled, locationEnabled);

        // Override context time with actual play time
        context.timeOfDay = ContextDetector.detectTimeOfDay(playedAt);
        context.dayOfWeek = ContextDetector.detectDayOfWeek(playedAt);

        const event: ListeningEvent = {
          id: '', // Will be generated by database
          userId,
          track: {
            id: item.track.id,
            name: item.track.name,
            artist: item.track.artists.map(a => a.name).join(', '),
            album: item.track.album.name,
            durationMs: item.track.duration_ms,
            imageUrl: item.track.album.images[0]?.url,
            spotifyUrl: item.track.external_urls.spotify,
          },
          audioFeatures,
          playedAt,
          context,
          engagement: {
            skipped: false, // We don't know if it was skipped from API
            playDurationMs: item.track.duration_ms, // Assume full play
            completed: true, // Assume completed since it's in history
            repeated: false,
          },
          createdAt: new Date(),
          syncedAt: new Date(),
        };

        events.push(event);
      }

      // Save all events to database
      if (events.length > 0) {
        await ListeningEventStore.saveEvents(events);
        console.log(`‚úÖ Synced ${events.length} new listening events`);
      }

      this.lastSyncTime = new Date();
      return events.length;

    } catch (error) {
      console.error('‚ùå Sync failed:', error);
      throw error;
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * Fetch audio features for multiple tracks in one request
   */
  private async fetchAudioFeaturesBatch(trackIds: string[]): Promise<Map<string, AudioFeatures>> {
    const featuresMap = new Map<string, AudioFeatures>();

    try {
      // Spotify allows up to 100 tracks per request (using existing service)
      const batchSize = 100;
      for (let i = 0; i < trackIds.length; i += batchSize) {
        const batch = trackIds.slice(i, i + batchSize);

        const features = await SpotifyService.getAudioFeatures(batch);

        if (features && Array.isArray(features)) {
          for (const feature of features) {
            if (feature && feature.id) {
              featuresMap.set(feature.id, {
                energy: feature.energy,
                valence: feature.valence,
                tempo: feature.tempo,
                danceability: feature.danceability,
                acousticness: feature.acousticness,
                instrumentalness: feature.instrumentalness,
                liveness: 0.5, // Default value since not in response
                speechiness: feature.speechiness,
                loudness: feature.loudness,
                mode: feature.mode,
                key: feature.key,
                time_signature: 4, // Default value since not in response
              });
            }
          }
        }
      }

      return featuresMap;
    } catch (error) {
      console.error('Failed to fetch audio features batch:', error);
      return featuresMap;
    }
  }

  /**
   * Get last sync time
   */
  getLastSyncTime(): Date | null {
    return this.lastSyncTime;
  }

  /**
   * Check if sync is in progress
   */
  isSyncInProgress(): boolean {
    return this.isSyncing;
  }

  /**
   * Get time since last sync (in minutes)
   */
  getMinutesSinceLastSync(): number | null {
    if (!this.lastSyncTime) return null;
    
    const now = new Date();
    const diffMs = now.getTime() - this.lastSyncTime.getTime();
    return Math.floor(diffMs / (1000 * 60));
  }

  /**
   * Check if sync is needed based on interval
   */
  shouldSync(intervalMinutes: number = 30): boolean {
    if (!this.lastSyncTime) return true;
    
    const minutesSince = this.getMinutesSinceLastSync();
    return minutesSince === null || minutesSince >= intervalMinutes;
  }
}

// Export singleton instance
export default new SpotifySync();
